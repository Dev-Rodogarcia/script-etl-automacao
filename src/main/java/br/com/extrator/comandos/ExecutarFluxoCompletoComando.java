package br.com.extrator.comandos;

import java.io.FileOutputStream;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import br.com.extrator.auditoria.CompletudeValidator;
import br.com.extrator.runners.DataExportRunner;
import br.com.extrator.runners.GraphQLRunner;
import br.com.extrator.runners.RestRunner;

/**
 * Comando respons√°vel por executar o fluxo completo de extra√ß√£o de dados
 * das 3 APIs do ESL Cloud (REST, GraphQL e DataExport).
 */
public class ExecutarFluxoCompletoComando implements Comando {
    private static final Logger logger = LoggerFactory.getLogger(ExecutarFluxoCompletoComando.class);
    
    // Constantes para grava√ß√£o do timestamp de execu√ß√£o
    private static final String ARQUIVO_ULTIMO_RUN = "last_run.properties";
    private static final String PROPRIEDADE_ULTIMO_RUN = "last_successful_run";
    
    @Override
    public void executar(String[] args) throws Exception {
        // Exibe banner inicial
        exibirBanner();
        
        // Define data de hoje para buscar dados do dia atual
        final LocalDate dataHoje = LocalDate.now();
        
        logger.info("Iniciando processo de extra√ß√£o de dados das 3 APIs do ESL Cloud");
        System.out.println("\n" + "=".repeat(60));
        System.out.println("INICIANDO PROCESSO DE EXTRA√á√ÉO DE DADOS");
        System.out.println("=".repeat(60));
        System.out.println("Modo: DADOS DE HOJE");
        System.out.println("Data de extra√ß√£o: " + dataHoje.format(DateTimeFormatter.ofPattern("dd/MM/yyyy")) + " (dados de hoje)");
        System.out.println("In√≠cio: " + LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss")));
        System.out.println("=".repeat(60) + "\n");
        
        final LocalDateTime inicioExecucao = LocalDateTime.now();
        
        try {
            // Executa API REST (Faturas e Ocorr√™ncias)
            System.out.println("üîÑ [1/3] Executando API REST...");
            RestRunner.executar(dataHoje);
            System.out.println("‚úÖ API REST conclu√≠da com sucesso!");
            
            // Pausa entre APIs para respeitar rate limit global
            System.out.println("‚è≥ Aguardando 2 segundos antes da pr√≥xima API...");
            Thread.sleep(2000);
            
            // Executa API GraphQL (Coletas e Fretes)
            System.out.println("\nüîÑ [2/3] Executando API GraphQL...");
            GraphQLRunner.executar(dataHoje);
            System.out.println("‚úÖ API GraphQL conclu√≠da com sucesso!");
            
            // Pausa entre APIs para respeitar rate limit global
            System.out.println("‚è≥ Aguardando 2 segundos antes da pr√≥xima API...");
            Thread.sleep(2000);
            
            // Executa API Data Export (Manifestos, Cota√ß√µes, Localiza√ß√£o)
            System.out.println("\nüîÑ [3/3] Executando API Data Export...");
            DataExportRunner.executar(dataHoje);
            System.out.println("‚úÖ API Data Export conclu√≠da com sucesso!");
            
            // ========== PASSO B: VALIDA√á√ÉO DE COMPLETUDE ==========
            // Somente ap√≥s a conclus√£o bem-sucedida de todas as extra√ß√µes,
            // instanciar e executar o CompletudeValidator
            System.out.println("\n" + "=".repeat(60));
            System.out.println("üîç INICIANDO VALIDA√á√ÉO DE COMPLETUDE DOS DADOS");
            System.out.println("=".repeat(60));
            
            // Instancia o validador
            final CompletudeValidator validator = new CompletudeValidator();
            
            // Passo B.1: Buscar totais da API ESL Cloud
            System.out.println("üîÑ [1/2] Buscando totais nas APIs do ESL Cloud...");
            final LocalDate dataReferencia = LocalDate.now();
            final Map<String, Integer> totaisEslCloud = validator.buscarTotaisEslCloud(dataReferencia);
            System.out.println("‚úÖ Totais obtidos das APIs com sucesso!");
            
            // Passo B.2: Validar completude comparando com o banco de dados
            System.out.println("üîÑ [2/2] Validando completude dos dados extra√≠dos...");
            final Map<String, CompletudeValidator.StatusValidacao> resultadosValidacao = validator.validarCompletude(totaisEslCloud, dataReferencia);
            
            // Determina se a extra√ß√£o est√° completa (todos os status devem ser OK)
            boolean extracaoCompleta = resultadosValidacao.values().stream()
                .allMatch(status -> status == CompletudeValidator.StatusValidacao.OK);
            
            // T√ìPICO 4: Valida√ß√µes Avan√ßadas (apenas se a valida√ß√£o b√°sica passou)
            boolean gapValidationOk = true;
            boolean temporalValidationOk = true;
            
            if (extracaoCompleta) {
                System.out.println("üîç [3/4] Executando valida√ß√£o de gaps (IDs sequenciais)...");
                CompletudeValidator.StatusValidacao gapStatus = validator.validarGapsOcorrencias(dataReferencia);
                gapValidationOk = (gapStatus == CompletudeValidator.StatusValidacao.OK);
                
                if (gapValidationOk) {
                    System.out.println("‚úÖ Valida√ß√£o de gaps: OK");
                    logger.info("‚úÖ Valida√ß√£o de gaps conclu√≠da com sucesso");
                } else {
                    System.out.println("‚ö†Ô∏è Valida√ß√£o de gaps: " + gapStatus);
                    logger.warn("‚ö†Ô∏è Valida√ß√£o de gaps detectou problemas: {}", gapStatus);
                }
                
                System.out.println("üïê [4/4] Executando valida√ß√£o de janela temporal...");
                Map<String, CompletudeValidator.StatusValidacao> temporalResults = validator.validarJanelaTemporal(dataReferencia);
                temporalValidationOk = temporalResults.values().stream()
                    .allMatch(status -> status == CompletudeValidator.StatusValidacao.OK);
                
                if (temporalValidationOk) {
                    System.out.println("‚úÖ Valida√ß√£o temporal: OK");
                    logger.info("‚úÖ Valida√ß√£o de janela temporal conclu√≠da com sucesso");
                } else {
                    System.out.println("‚ùå Valida√ß√£o temporal detectou problemas cr√≠ticos!");
                    logger.error("‚ùå Valida√ß√£o temporal detectou registros criados durante extra√ß√£o - risco de perda de dados");
                }
            }
            
            // Determina resultado final considerando todas as valida√ß√µes
            boolean validacaoFinalCompleta = extracaoCompleta && gapValidationOk && temporalValidationOk;
            
            // Exibe resultado final da valida√ß√£o
            System.out.println("\n" + "=".repeat(60));
            if (validacaoFinalCompleta) {
                System.out.println("üéâ EXTRA√á√ÉO 100% COMPLETA E VALIDADA!");
                System.out.println("‚úÖ Todos os dados foram extra√≠dos com sucesso!");
                System.out.println("‚úÖ Valida√ß√£o de gaps: OK");
                System.out.println("‚úÖ Valida√ß√£o temporal: OK");
                logger.info("üéâ EXTRA√á√ÉO 100% COMPLETA! Todas as valida√ß√µes (b√°sica, gaps e temporal) foram bem-sucedidas.");
            } else {
                System.out.println("‚ùå EXTRA√á√ÉO COM PROBLEMAS - Verificar logs");
                if (!extracaoCompleta) {
                    System.out.println("‚ö†Ô∏è  Inconsist√™ncias na contagem de registros detectadas.");
                }
                if (!gapValidationOk) {
                    System.out.println("‚ö†Ô∏è  Gaps nos IDs detectados - poss√≠vel perda de registros espec√≠ficos.");
                }
                if (!temporalValidationOk) {
                    System.out.println("‚ùå CR√çTICO: Registros criados durante extra√ß√£o - risco de perda de dados!");
                }
                System.out.println("üí° Consulte os logs detalhados para identificar os problemas.");
                logger.error("‚ùå EXTRA√á√ÉO COM PROBLEMAS - B√°sica: {}, Gaps: {}, Temporal: {}", 
                    extracaoCompleta, gapValidationOk, temporalValidationOk);
                
                // Nota: Implementa√ß√£o futura de alertas por email/Slack pode ser adicionada aqui
            }
            System.out.println("=".repeat(60));
            
            // Exibe resumo final
            final LocalDateTime fimExecucao = LocalDateTime.now();
            System.out.println("\n" + "=".repeat(60));
            System.out.println("PROCESSO DE EXTRA√á√ÉO E VALIDA√á√ÉO CONCLU√çDO");
            System.out.println("=".repeat(60));
            System.out.println("In√≠cio: " + inicioExecucao.format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss")));
            System.out.println("Fim: " + fimExecucao.format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss")));
            System.out.println("Dura√ß√£o: " + java.time.Duration.between(inicioExecucao, fimExecucao).toMinutes() + " minutos");
            System.out.println("‚úÖ Todas as 3 APIs foram processadas e validadas!");
            System.out.println("=".repeat(60));
            
            // Grava timestamp de execu√ß√£o bem-sucedida
            gravarDataExecucao();
            
        } catch (final Exception e) {
            logger.error("Falha durante a execu√ß√£o do fluxo completo: {}", e.getMessage(), e);
            throw e; // Re-propaga para tratamento de alto n√≠vel
        }
    }
    
    private void exibirBanner() {
        System.out.println("=".repeat(80));
        System.out.println("üöÄ SISTEMA DE EXTRA√á√ÉO DE DADOS - ESL CLOUD");
        System.out.println("=".repeat(80));
        System.out.println("Vers√£o: 3.0 - Arquitetura Refatorada com Padr√£o Command");
        System.out.println("Desenvolvido para automa√ß√£o de extra√ß√£o de dados via APIs");
        System.out.println("=".repeat(80));
    }
    
    /**
     * Grava timestamp da execu√ß√£o bem-sucedida.
     */
    private void gravarDataExecucao() {
        try {
            final Properties props = new Properties();
            props.setProperty(PROPRIEDADE_ULTIMO_RUN, LocalDateTime.now().toString());
            
            try (final FileOutputStream fos = new FileOutputStream(ARQUIVO_ULTIMO_RUN)) {
                props.store(fos, "√öltima execu√ß√£o bem-sucedida do sistema de extra√ß√£o");
            }
            
            logger.info("Timestamp de execu√ß√£o gravado com sucesso");
        } catch (final IOException e) {
            logger.warn("N√£o foi poss√≠vel gravar timestamp de execu√ß√£o: {}", e.getMessage());
        }
    }
}