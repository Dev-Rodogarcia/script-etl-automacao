package br.com.extrator.auditoria;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import br.com.extrator.api.ClienteApiDataExport;
import br.com.extrator.api.ClienteApiGraphQL;
import br.com.extrator.api.ClienteApiRest;
import br.com.extrator.util.GerenciadorConexao;

/**
 * Motor central da auditoria comparativa que orquestra a busca de contagens
 * e a compara√ß√£o com o banco de dados.
 * 
 * Esta classe implementa o T√≥pico 2 da documenta√ß√£o, sendo respons√°vel por:
 * - Orquestrar chamadas aos clientes de API para obter contagens do ESL Cloud
 * - Comparar essas contagens com os dados armazenados no banco de dados local
 * - Gerar relat√≥rios de completude com status claros (‚úÖ OK, ‚ùå INCOMPLETO, ‚ö†Ô∏è DUPLICADOS)
 * 
 * @author Sistema de Extra√ß√£o ESL Cloud
 * @version 1.0
 */
public class CompletudeValidator {
    private static final Logger logger = LoggerFactory.getLogger(CompletudeValidator.class);
    
    // Clientes de API para buscar contagens do ESL Cloud
    private final ClienteApiRest clienteApiRest;
    private final ClienteApiGraphQL clienteApiGraphQL;
    private final ClienteApiDataExport clienteApiDataExport;
    
    // Mapeamento de entidades para nomes de tabelas no banco
    private static final Map<String, String> MAPEAMENTO_ENTIDADES_TABELAS = Map.of(
        "ocorrencias", "ocorrencias",
        "faturas_a_receber", "faturas_a_receber",
        "faturas_a_pagar", "faturas_a_pagar",
        "fretes", "fretes",
        "coletas", "coletas",
        "manifestos", "manifestos",
        "cotacoes", "cotacoes",
        "localizacao_cargas", "localizacao_cargas"
    );
    
    /**
     * Construtor que inicializa os clientes de API necess√°rios.
     * Utiliza inje√ß√£o de depend√™ncia para facilitar testes e manuten√ß√£o.
     */
    public CompletudeValidator() {
        this.clienteApiRest = new ClienteApiRest();
        this.clienteApiGraphQL = new ClienteApiGraphQL();
        this.clienteApiDataExport = new ClienteApiDataExport();
        
        logger.info("CompletudeValidator inicializado com todos os clientes de API");
    }
    
    /**
     * Construtor alternativo para inje√ß√£o de depend√™ncia (√∫til para testes).
     * 
     * @param clienteApiRest Cliente da API REST
     * @param clienteApiGraphQL Cliente da API GraphQL
     * @param clienteApiDataExport Cliente da API DataExport
     */
    public CompletudeValidator(ClienteApiRest clienteApiRest, 
                              ClienteApiGraphQL clienteApiGraphQL,
                              ClienteApiDataExport clienteApiDataExport) {
        this.clienteApiRest = clienteApiRest;
        this.clienteApiGraphQL = clienteApiGraphQL;
        this.clienteApiDataExport = clienteApiDataExport;
        
        logger.info("CompletudeValidator inicializado com clientes injetados");
    }
    
    /**
     * Orquestrador principal que busca totais de todas as entidades do ESL Cloud.
     * 
     * Este m√©todo √© o cora√ß√£o do T√≥pico 1, coordenando chamadas sequenciais para:
     * - ClienteApiRest: ocorr√™ncias, faturas a receber, faturas a pagar
     * - ClienteApiGraphQL: fretes, coletas  
     * - ClienteApiDataExport: manifestos, cota√ß√µes, localiza√ß√µes de carga
     * 
     * @param dataReferencia Data de refer√™ncia para buscar as contagens
     * @return Map com chave=nome_entidade e valor=contagem_esl_cloud
     */
    public Map<String, Integer> buscarTotaisEslCloud(LocalDate dataReferencia) {
        logger.info("üîç Iniciando busca de totais do ESL Cloud para data: {}", dataReferencia);
        
        Map<String, Integer> totaisEslCloud = new HashMap<>();
        
        try {
            // === API REST - Ocorr√™ncias e Faturas ===
            logger.info("üì° Buscando contagens via API REST...");
            
            // Ocorr√™ncias
            int contagemOcorrencias = clienteApiRest.obterContagemOcorrencias(dataReferencia);
            totaisEslCloud.put("ocorrencias", contagemOcorrencias);
            logger.info("‚úÖ Ocorr√™ncias: {} registros", contagemOcorrencias);
            
            // Faturas a Receber
            int contagemFaturasReceber = clienteApiRest.obterContagemFaturasAReceber(dataReferencia);
            totaisEslCloud.put("faturas_a_receber", contagemFaturasReceber);
            logger.info("‚úÖ Faturas a Receber: {} registros", contagemFaturasReceber);
            
            // Faturas a Pagar
            int contagemFaturasPagar = clienteApiRest.obterContagemFaturasAPagar(dataReferencia);
            totaisEslCloud.put("faturas_a_pagar", contagemFaturasPagar);
            logger.info("‚úÖ Faturas a Pagar: {} registros", contagemFaturasPagar);
            
            // === API GraphQL - Fretes e Coletas ===
            logger.info("üîó Buscando contagens via API GraphQL...");
            
            // Fretes
            int contagemFretes = clienteApiGraphQL.obterContagemFretes(dataReferencia);
            totaisEslCloud.put("fretes", contagemFretes);
            logger.info("‚úÖ Fretes: {} registros", contagemFretes);
            
            // Coletas
            int contagemColetas = clienteApiGraphQL.obterContagemColetas(dataReferencia);
            totaisEslCloud.put("coletas", contagemColetas);
            logger.info("‚úÖ Coletas: {} registros", contagemColetas);
            
            // === API DataExport - Manifestos, Cota√ß√µes e Localiza√ß√µes ===
            logger.info("üìä Buscando contagens via API DataExport...");
            
            // Manifestos
            int contagemManifestos = clienteApiDataExport.obterContagemManifestos(dataReferencia);
            totaisEslCloud.put("manifestos", contagemManifestos);
            logger.info("‚úÖ Manifestos: {} registros", contagemManifestos);
            
            // Cota√ß√µes
            int contagemCotacoes = clienteApiDataExport.obterContagemCotacoes(dataReferencia);
            totaisEslCloud.put("cotacoes", contagemCotacoes);
            logger.info("‚úÖ Cota√ß√µes: {} registros", contagemCotacoes);
            
            // Localiza√ß√µes de Carga
            int contagemLocalizacoes = clienteApiDataExport.obterContagemLocalizacoesCarga(dataReferencia);
            totaisEslCloud.put("localizacao_cargas", contagemLocalizacoes);
            logger.info("‚úÖ Localiza√ß√µes de Carga: {} registros", contagemLocalizacoes);
            
            // Log do resumo final
            int totalGeralRegistros = totaisEslCloud.values().stream().mapToInt(Integer::intValue).sum();
            logger.info("üéØ Busca de totais ESL Cloud conclu√≠da: {} entidades, {} registros totais", 
                    totaisEslCloud.size(), totalGeralRegistros);
            
        } catch (Exception e) {
            logger.error("‚ùå Erro ao buscar totais do ESL Cloud: {}", e.getMessage(), e);
            throw new RuntimeException("Falha na busca de totais do ESL Cloud", e);
        }
        
        return totaisEslCloud;
    }
    
    /**
     * Valida a completude dos dados comparando contagens do ESL Cloud com o banco local.
     * 
     * Implementa a l√≥gica de compara√ß√£o usando queries SQL eficientes com String.format
     * (seguro pois os nomes das tabelas v√™m de fonte controlada - as chaves do Map).
     * 
     * Gera logs com status claros:
     * - ‚úÖ OK: contagens coincidem
     * - ‚ùå INCOMPLETO: banco tem menos registros que ESL Cloud  
     * - ‚ö†Ô∏è DUPLICADOS: banco tem mais registros que ESL Cloud
     * 
     * @param totaisEslCloud Map com contagens obtidas do ESL Cloud
     * @param dataReferencia Data de refer√™ncia para filtrar consultas no banco
     * @return Map com resultado da valida√ß√£o por entidade
     */
    public Map<String, StatusValidacao> validarCompletude(Map<String, Integer> totaisEslCloud, 
                                                         LocalDate dataReferencia) {
        logger.info("üîç Iniciando valida√ß√£o de completude para {} entidades na data: {}", 
                totaisEslCloud.size(), dataReferencia);
        
        Map<String, StatusValidacao> resultadosValidacao = new HashMap<>();
        
        try (Connection conexao = GerenciadorConexao.obterConexao()) {
            
            for (Map.Entry<String, Integer> entrada : totaisEslCloud.entrySet()) {
                String nomeEntidade = entrada.getKey();
                int contagemEslCloud = entrada.getValue();
                
                // Obter nome da tabela correspondente
                String nomeTabela = MAPEAMENTO_ENTIDADES_TABELAS.get(nomeEntidade);
                if (nomeTabela == null) {
                    logger.warn("‚ö†Ô∏è Entidade '{}' n√£o possui mapeamento para tabela. Pulando valida√ß√£o.", nomeEntidade);
                    resultadosValidacao.put(nomeEntidade, StatusValidacao.ERRO);
                    continue;
                }
                
                try {
                    // Query SQL eficiente para contar registros na data espec√≠fica
                    // String.format √© seguro aqui pois nomeTabela vem de fonte controlada
                    String sql = String.format(
                        "SELECT COUNT(*) FROM %s WHERE DATE(data_extracao) = ?", 
                        nomeTabela
                    );
                    
                    int contagemBanco;
                    try (PreparedStatement stmt = conexao.prepareStatement(sql)) {
                        stmt.setDate(1, java.sql.Date.valueOf(dataReferencia));
                        
                        try (ResultSet rs = stmt.executeQuery()) {
                            rs.next();
                            contagemBanco = rs.getInt(1);
                        }
                    }
                    
                    // Determinar status baseado na compara√ß√£o
                    StatusValidacao status = determinarStatusValidacao(contagemEslCloud, contagemBanco);
                    resultadosValidacao.put(nomeEntidade, status);
                    
                    // Log com status visual claro
                    String iconeStatus = obterIconeStatus(status);
                    logger.info("{} {}: ESL Cloud={}, Banco={}", 
                            iconeStatus, nomeEntidade, contagemEslCloud, contagemBanco);
                    
                } catch (SQLException e) {
                    logger.error("‚ùå Erro SQL ao validar entidade '{}': {}", nomeEntidade, e.getMessage(), e);
                    resultadosValidacao.put(nomeEntidade, StatusValidacao.ERRO);
                }
            }
            
            // Log do resumo final
            long totalOk = resultadosValidacao.values().stream()
                    .filter(status -> status == StatusValidacao.OK).count();
            long totalIncompleto = resultadosValidacao.values().stream()
                    .filter(status -> status == StatusValidacao.INCOMPLETO).count();
            long totalDuplicados = resultadosValidacao.values().stream()
                    .filter(status -> status == StatusValidacao.DUPLICADOS).count();
            long totalErros = resultadosValidacao.values().stream()
                    .filter(status -> status == StatusValidacao.ERRO).count();
            
            logger.info("üìä Valida√ß√£o de completude conclu√≠da: ‚úÖ {} OK, ‚ùå {} INCOMPLETO, ‚ö†Ô∏è {} DUPLICADOS, üí• {} ERROS", 
                    totalOk, totalIncompleto, totalDuplicados, totalErros);
            
        } catch (SQLException e) {
            logger.error("‚ùå Erro ao conectar com banco de dados para valida√ß√£o: {}", e.getMessage(), e);
            throw new RuntimeException("Falha na conex√£o com banco de dados", e);
        }
        
        return resultadosValidacao;
    }
    
    /**
     * Determina o status de valida√ß√£o baseado na compara√ß√£o entre contagens.
     * 
     * @param contagemEslCloud Contagem obtida do ESL Cloud
     * @param contagemBanco Contagem obtida do banco local
     * @return Status da valida√ß√£o
     */
    private StatusValidacao determinarStatusValidacao(int contagemEslCloud, int contagemBanco) {
        if (contagemEslCloud == contagemBanco) {
            return StatusValidacao.OK;
        } else if (contagemBanco < contagemEslCloud) {
            return StatusValidacao.INCOMPLETO;
        } else {
            return StatusValidacao.DUPLICADOS;
        }
    }
    
    /**
     * Obt√©m o √≠cone visual correspondente ao status de valida√ß√£o.
     * 
     * @param status Status da valida√ß√£o
     * @return String com √≠cone visual
     */
    private String obterIconeStatus(StatusValidacao status) {
        return switch (status) {
            case OK -> "‚úÖ OK";
            case INCOMPLETO -> "‚ùå INCOMPLETO";
            case DUPLICADOS -> "‚ö†Ô∏è DUPLICADOS";
            case ERRO -> "üí• ERRO";
        };
    }
    
    /**
     * T√ìPICO 4: Valida√ß√£o de Gaps - Verifica se os IDs das ocorr√™ncias s√£o sequenciais
     * 
     * Pr√©-requisito: Esta valida√ß√£o s√≥ deve ser executada se os IDs forem realmente sequenciais.
     * Caso contr√°rio, a estrat√©gia de detec√ß√£o de gaps n√£o funcionar√°.
     * 
     * @param dataReferencia Data de refer√™ncia para an√°lise
     * @return StatusValidacao indicando se h√° gaps nos IDs
     */
    public StatusValidacao validarGapsOcorrencias(LocalDate dataReferencia) {
        logger.info("üîç Iniciando valida√ß√£o de gaps para ocorr√™ncias...");
        
        try (Connection conexao = GerenciadorConexao.obterConexao()) {
            // Primeiro, verificar se os IDs s√£o sequenciais
            if (!verificarIdsSequenciais(conexao, "ocorrencias")) {
                logger.warn("‚ö†Ô∏è IDs das ocorr√™ncias n√£o s√£o sequenciais - valida√ß√£o de gaps n√£o aplic√°vel");
                return StatusValidacao.OK; // N√£o √© erro, apenas n√£o aplic√°vel
            }
            
            // Se s√£o sequenciais, verificar gaps
            return detectarGapsSequenciais(conexao, "ocorrencias", dataReferencia);
            
        } catch (SQLException e) {
            logger.error("‚ùå Erro ao validar gaps nas ocorr√™ncias: {}", e.getMessage(), e);
            return StatusValidacao.ERRO;
        }
    }
    
    /**
     * Verifica se os IDs de uma tabela s√£o sequenciais (sem pulos).
     * 
     * @param conexao Conex√£o com o banco de dados
     * @param nomeTabela Nome da tabela a verificar
     * @return true se os IDs s√£o sequenciais, false caso contr√°rio
     */
    private boolean verificarIdsSequenciais(Connection conexao, String nomeTabela) throws SQLException {
        String sql = """
            WITH ids_ordenados AS (
                SELECT id, ROW_NUMBER() OVER (ORDER BY id) as posicao
                FROM %s
                WHERE data_extracao >= DATEADD(day, -7, GETDATE()) -- √öltimos 7 dias para an√°lise
            ),
            gaps AS (
                SELECT COUNT(*) as total_gaps
                FROM ids_ordenados
                WHERE id != (SELECT MIN(id) FROM ids_ordenados) + posicao - 1
            )
            SELECT CASE WHEN total_gaps = 0 THEN 1 ELSE 0 END as ids_sequenciais
            FROM gaps
            """.formatted(nomeTabela);
        
        try (PreparedStatement stmt = conexao.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            
            if (rs.next()) {
                boolean sequencial = rs.getInt("ids_sequenciais") == 1;
                logger.info("üìä An√°lise de sequencialidade para {}: {}", nomeTabela, 
                    sequencial ? "IDs s√£o sequenciais" : "IDs t√™m gaps/pulos");
                return sequencial;
            }
            return false;
        }
    }
    
    /**
     * Detecta gaps em IDs sequenciais usando a estrat√©gia WITH ids_esperados.
     * 
     * @param conexao Conex√£o com o banco de dados
     * @param nomeTabela Nome da tabela a verificar
     * @param dataReferencia Data de refer√™ncia para an√°lise
     * @return StatusValidacao indicando se h√° gaps
     */
    private StatusValidacao detectarGapsSequenciais(Connection conexao, String nomeTabela, LocalDate dataReferencia) throws SQLException {
        String sql = """
            WITH ids_esperados AS (
                SELECT MIN(id) + n.number as id_esperado
                FROM %s,
                     (SELECT TOP ((SELECT MAX(id) - MIN(id) + 1 FROM %s WHERE data_extracao >= ?))
                             ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1 as number
                      FROM sys.objects a CROSS JOIN sys.objects b) n
                WHERE data_extracao >= ?
            ),
            gaps AS (
                SELECT ie.id_esperado
                FROM ids_esperados ie
                LEFT JOIN %s o ON ie.id_esperado = o.id AND o.data_extracao >= ?
                WHERE o.id IS NULL
            )
            SELECT COUNT(*) as total_gaps
            FROM gaps
            """.formatted(nomeTabela, nomeTabela, nomeTabela);
        
        try (PreparedStatement stmt = conexao.prepareStatement(sql)) {
            java.sql.Date sqlDate = java.sql.Date.valueOf(dataReferencia);
            stmt.setDate(1, sqlDate);
            stmt.setDate(2, sqlDate);
            stmt.setDate(3, sqlDate);
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int totalGaps = rs.getInt("total_gaps");
                    
                    if (totalGaps == 0) {
                        logger.info("‚úÖ Nenhum gap detectado nos IDs de {}", nomeTabela);
                        return StatusValidacao.OK;
                    } else {
                        logger.warn("‚ö†Ô∏è Detectados {} gaps nos IDs de {} - poss√≠vel perda de dados", totalGaps, nomeTabela);
                        return StatusValidacao.INCOMPLETO;
                    }
                }
                return StatusValidacao.ERRO;
            }
        }
    }
    
    /**
     * T√ìPICO 4: Valida√ß√£o da Janela Temporal - Detecta registros criados durante a extra√ß√£o
     * 
     * Esta √© a valida√ß√£o mais complexa. Verifica se h√° registros criados entre o in√≠cio
     * e fim da extra√ß√£o que podem ter sido perdidos devido a problemas de pagina√ß√£o da API.
     * 
     * @param dataReferencia Data de refer√™ncia para an√°lise
     * @return Map com status de valida√ß√£o por entidade
     */
    public Map<String, StatusValidacao> validarJanelaTemporal(LocalDate dataReferencia) {
        logger.info("üïê Iniciando valida√ß√£o de janela temporal para data: {}", dataReferencia);
        
        Map<String, StatusValidacao> resultados = new HashMap<>();
        
        try (Connection conexao = GerenciadorConexao.obterConexao()) {
            // Buscar timestamps de extra√ß√£o do log
            Map<String, TimestampsExtracao> timestampsExtracao = buscarTimestampsExtracao(conexao, dataReferencia);
            
            // Validar cada entidade
            for (String entidade : MAPEAMENTO_ENTIDADES_TABELAS.keySet()) {
                TimestampsExtracao timestamps = timestampsExtracao.get(entidade);
                
                if (timestamps == null) {
                    logger.warn("‚ö†Ô∏è Nenhum log de extra√ß√£o encontrado para {} na data {}", entidade, dataReferencia);
                    resultados.put(entidade, StatusValidacao.ERRO);
                    continue;
                }
                
                StatusValidacao status = validarJanelaTemporalEntidade(entidade, timestamps, dataReferencia);
                resultados.put(entidade, status);
            }
            
        } catch (SQLException e) {
            logger.error("‚ùå Erro ao validar janela temporal: {}", e.getMessage(), e);
            // Marcar todas as entidades como erro
            for (String entidade : MAPEAMENTO_ENTIDADES_TABELAS.keySet()) {
                resultados.put(entidade, StatusValidacao.ERRO);
            }
        }
        
        return resultados;
    }
    
    /**
     * Busca os timestamps de in√≠cio e fim das extra√ß√µes do log_extracoes.
     * 
     * @param conexao Conex√£o com o banco de dados
     * @param dataReferencia Data de refer√™ncia
     * @return Map com timestamps por entidade
     */
    private Map<String, TimestampsExtracao> buscarTimestampsExtracao(Connection conexao, LocalDate dataReferencia) throws SQLException {
        String sql = """
            SELECT entidade, timestamp_inicio, timestamp_fim
            FROM log_extracoes
            WHERE CAST(timestamp_inicio AS DATE) = ?
            AND status_final = 'COMPLETO'
            ORDER BY timestamp_inicio DESC
            """;
        
        Map<String, TimestampsExtracao> timestamps = new HashMap<>();
        
        try (PreparedStatement stmt = conexao.prepareStatement(sql)) {
            stmt.setDate(1, java.sql.Date.valueOf(dataReferencia));
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    String entidade = rs.getString("entidade");
                    java.sql.Timestamp inicio = rs.getTimestamp("timestamp_inicio");
                    java.sql.Timestamp fim = rs.getTimestamp("timestamp_fim");
                    
                    timestamps.put(entidade, new TimestampsExtracao(inicio, fim));
                }
            }
        }
        
        logger.info("üìä Encontrados timestamps para {} entidades na data {}", timestamps.size(), dataReferencia);
        return timestamps;
    }
    
    /**
     * Valida a janela temporal para uma entidade espec√≠fica.
     * 
     * @param entidade Nome da entidade
     * @param timestamps Timestamps de in√≠cio e fim da extra√ß√£o
     * @param dataReferencia Data de refer√™ncia
     * @return StatusValidacao da janela temporal
     */
    private StatusValidacao validarJanelaTemporalEntidade(String entidade, TimestampsExtracao timestamps, LocalDate dataReferencia) {
        try {
            // Fazer chamada √† API para contar registros criados durante a janela de extra√ß√£o
            int registrosDuranteExtracao = contarRegistrosDuranteJanela(entidade, timestamps, dataReferencia);
            
            if (registrosDuranteExtracao == 0) {
                logger.info("‚úÖ Nenhum registro criado durante extra√ß√£o de {} - janela temporal OK", entidade);
                return StatusValidacao.OK;
            } else {
                logger.error("‚ùå CR√çTICO: {} registros de {} foram criados durante a extra√ß√£o! Risco de perda de dados devido a falha na pagina√ß√£o da API", 
                    registrosDuranteExtracao, entidade);
                return StatusValidacao.INCOMPLETO;
            }
            
        } catch (Exception e) {
            logger.error("‚ùå Erro ao validar janela temporal para {}: {}", entidade, e.getMessage(), e);
            return StatusValidacao.ERRO;
        }
    }
    
    /**
     * Conta registros criados durante a janela de extra√ß√£o via API.
     * 
     * @param entidade Nome da entidade
     * @param timestamps Timestamps da extra√ß√£o
     * @param dataReferencia Data de refer√™ncia
     * @return N√∫mero de registros criados durante a extra√ß√£o
     */
    private int contarRegistrosDuranteJanela(String entidade, TimestampsExtracao timestamps, LocalDate dataReferencia) {
        // Implementar chamadas espec√≠ficas para cada tipo de API
        return switch (entidade) {
            case "ocorrencias", "faturas_a_receber", "faturas_a_pagar" ->
                contarRegistrosApiRest(entidade, timestamps, dataReferencia);
                
            case "fretes", "coletas" ->
                contarRegistrosApiGraphQL(entidade, timestamps, dataReferencia);
                
            case "manifestos", "cotacoes", "localizacao_cargas" ->
                contarRegistrosApiDataExport(entidade, timestamps, dataReferencia);
                
            default -> {
                logger.warn("‚ö†Ô∏è Entidade {} n√£o mapeada para valida√ß√£o temporal", entidade);
                yield 0;
            }
        };
    }
    
    /**
     * Conta registros via API REST durante janela temporal.
     * 
     * @param entidade Nome da entidade a ser consultada
     * @param timestamps Janela temporal da extra√ß√£o (ser√° usado na implementa√ß√£o futura)
     * @param dataReferencia Data de refer√™ncia para filtros (ser√° usado na implementa√ß√£o futura)
     * @return N√∫mero de registros encontrados na janela temporal
     */
    private int contarRegistrosApiRest(String entidade, TimestampsExtracao timestamps, LocalDate dataReferencia) {
        // Implementa√ß√£o espec√≠fica para API REST
        // Por enquanto, retorna 0 (implementa√ß√£o futura)
        logger.debug("üîÑ Contagem temporal via API REST para {} ainda n√£o implementada (janela: {} - {}, data: {})", 
                    entidade, timestamps.getInicio(), timestamps.getFim(), dataReferencia);
        return 0;
    }
    
    /**
     * Conta registros via API GraphQL durante janela temporal.
     * 
     * @param entidade Nome da entidade a ser consultada
     * @param timestamps Janela temporal da extra√ß√£o (ser√° usado na implementa√ß√£o futura)
     * @param dataReferencia Data de refer√™ncia para filtros (ser√° usado na implementa√ß√£o futura)
     * @return N√∫mero de registros encontrados na janela temporal
     */
    private int contarRegistrosApiGraphQL(String entidade, TimestampsExtracao timestamps, LocalDate dataReferencia) {
        // Implementa√ß√£o espec√≠fica para API GraphQL
        // Por enquanto, retorna 0 (implementa√ß√£o futura)
        logger.debug("üîÑ Contagem temporal via API GraphQL para {} ainda n√£o implementada (janela: {} - {}, data: {})", 
                    entidade, timestamps.getInicio(), timestamps.getFim(), dataReferencia);
        return 0;
    }
    
    /**
     * Conta registros via API Data Export durante janela temporal.
     * 
     * @param entidade Nome da entidade a ser consultada
     * @param timestamps Janela temporal da extra√ß√£o (ser√° usado na implementa√ß√£o futura)
     * @param dataReferencia Data de refer√™ncia para filtros (ser√° usado na implementa√ß√£o futura)
     * @return N√∫mero de registros encontrados na janela temporal
     */
    private int contarRegistrosApiDataExport(String entidade, TimestampsExtracao timestamps, LocalDate dataReferencia) {
        // Implementa√ß√£o espec√≠fica para API Data Export
        // Por enquanto, retorna 0 (implementa√ß√£o futura)
        logger.debug("üîÑ Contagem temporal via API Data Export para {} ainda n√£o implementada (janela: {} - {}, data: {})", 
                    entidade, timestamps.getInicio(), timestamps.getFim(), dataReferencia);
        return 0;
    }
    
    /**
     * Classe auxiliar para armazenar timestamps de extra√ß√£o.
     */
    private static class TimestampsExtracao {
        private final java.sql.Timestamp inicio;
        private final java.sql.Timestamp fim;
        
        public TimestampsExtracao(java.sql.Timestamp inicio, java.sql.Timestamp fim) {
            this.inicio = inicio;
            this.fim = fim;
        }
        
        public java.sql.Timestamp getInicio() { return inicio; }
        
        public java.sql.Timestamp getFim() { return fim; }
    }
    
    /**
     * Enum para representar os poss√≠veis status de valida√ß√£o de completude.
     */
    public enum StatusValidacao {
        /** Contagens coincidem - dados completos */
        OK,
        /** Banco tem menos registros que ESL Cloud - dados incompletos */
        INCOMPLETO,
        /** Banco tem mais registros que ESL Cloud - poss√≠veis duplicados */
        DUPLICADOS,
        /** Erro durante a valida√ß√£o */
        ERRO
    }
}