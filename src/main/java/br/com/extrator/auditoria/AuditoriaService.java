package br.com.extrator.auditoria;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import br.com.extrator.util.GerenciadorConexao;

/**
 * Servi√ßo principal de auditoria que coordena a valida√ß√£o da completude
 * dos dados extra√≠dos das APIs do ESL Cloud.
 * 
 * Verifica se todas as entidades foram extra√≠das corretamente e gera
 * relat√≥rios de auditoria para identificar poss√≠veis inconsist√™ncias.
 */
public class AuditoriaService {
    private static final Logger logger = LoggerFactory.getLogger(AuditoriaService.class);

    private final AuditoriaValidator validator;
    private final AuditoriaRelatorio relatorio;
    private final CompletudeValidator completudeValidator; // ‚Üê NOVO

    public AuditoriaService() {
        this.validator = new AuditoriaValidator();
        this.relatorio = new AuditoriaRelatorio();
        this.completudeValidator = new CompletudeValidator(); // ‚Üê NOVO
    }

    /**
     * Executa auditoria completa dos dados extra√≠dos nas √∫ltimas 24 horas.
     * 
     * @return ResultadoAuditoria com o resultado da auditoria
     */
    public ResultadoAuditoria executarAuditoriaCompleta() {
        logger.info("üîç Iniciando auditoria completa dos dados extra√≠dos");

        final Instant agora = Instant.now();
        final Instant inicio24h = agora.minusSeconds(24 * 60 * 60); // 24 horas em segundos

        return executarAuditoriaPorPeriodo(inicio24h, agora);
    }

    /**
     * Executa auditoria dos dados extra√≠dos em um per√≠odo espec√≠fico.
     * 
     * @param dataInicio Data de in√≠cio do per√≠odo
     * @param dataFim    Data de fim do per√≠odo
     * @return ResultadoAuditoria com o resultado da auditoria
     */
    public ResultadoAuditoria executarAuditoriaPorPeriodo(final Instant dataInicio, final Instant dataFim) {
        final ResultadoAuditoria resultado = new ResultadoAuditoria();
        resultado.setDataInicio(dataInicio);
        resultado.setDataFim(dataFim);
        resultado.setDataExecucao(Instant.now());

        try (Connection conexao = GerenciadorConexao.obterConexao()) {
            // ‚úÖ FASE 1: Buscar API (com fallback)
            Map<String, Integer> totaisApi = null;
            try {
                logger.info("üîç Buscando API...");
                totaisApi = completudeValidator.buscarTotaisEslCloud(java.time.LocalDate.now());
            } catch (final Exception e) {
                logger.error("‚ùå API falhou: {} - Continuando local", e.getMessage());
            }

            // ‚úÖ FASE 2: Validar com compara√ß√£o
            final List<String> ents = List.of("cotacoes", "coletas", "faturas_a_pagar",
                    "faturas_a_receber", "fretes", "manifestos", "ocorrencias", "localizacao_cargas");

            for (final String e : ents) {
                try {
                    ResultadoValidacaoEntidade v;
                    if (totaisApi != null && totaisApi.containsKey(e)) {
                        // Comparar banco vs API
                        final long banco = contarRegistrosNoBanco(conexao, e, dataInicio, dataFim);
                        final int esperado = totaisApi.get(e);

                        if (banco == esperado) {
                            // ‚úÖ Dados completos
                            v = ResultadoValidacaoEntidade.completo(e, esperado, (int) banco);
                            logger.info("‚úÖ {} - COMPLETO: {}/{} registros (100%)", e, banco, esperado);
                        } else if (banco < esperado) {
                            // ‚ùå Dados incompletos
                            v = ResultadoValidacaoEntidade.incompleto(e, esperado, (int) banco);
                            final double perc = (banco * 100.0) / esperado;
                            logger.warn("‚ùå {} - INCOMPLETO: {}/{} registros ({:.1f}% - faltam {})",
                                    e, banco, esperado, perc, esperado - banco);
                        } else {
                            // ‚ö†Ô∏è Dados duplicados
                            v = ResultadoValidacaoEntidade.duplicados(e, esperado, (int) banco);
                            logger.warn("‚ö†Ô∏è {} - DUPLICADOS: {} registros (esperado: {}, excesso: {})",
                                    e, banco, esperado, banco - esperado);
                        }
                    } else {
                        v = validator.validarEntidade(conexao, e, dataInicio, dataFim);
                    }
                    resultado.adicionarValidacao(e, v);
                } catch (SQLException | RuntimeException ex) {
                    resultado.adicionarValidacao(e, ResultadoValidacaoEntidade.erro(e, 0, ex.getMessage()));
                }
            }

            // ‚úÖ SEMPRE gerar relat√≥rio
            resultado.determinarStatusGeral();
            relatorio.gerarRelatorio(resultado);

        } catch (SQLException | RuntimeException ex) {
            resultado.setErro(ex.getMessage());
            resultado.setStatusGeral(StatusAuditoria.ERRO);
            try {
                relatorio.gerarRelatorio(resultado);
            } catch (final Exception e) {
            }
        }

        return resultado;
    }

    // ‚úÖ NOVO M√âTODO
    private long contarRegistrosNoBanco(final Connection c, final String e, final Instant i, final Instant f)
            throws SQLException {
        final String sql = String.format("SELECT COUNT(*) FROM %s WHERE data_extracao BETWEEN ? AND ?", e);
        try (PreparedStatement s = c.prepareStatement(sql)) {
            s.setTimestamp(1, Timestamp.from(i));
            s.setTimestamp(2, Timestamp.from(f));
            try (ResultSet r = s.executeQuery()) {
                return r.next() ? r.getLong(1) : 0;
            }
        } catch (final SQLException ex) {
            // Fallback: tentar com created_at
            final String sql2 = String.format("SELECT COUNT(*) FROM %s WHERE created_at BETWEEN ? AND ?", e);
            try (PreparedStatement s = c.prepareStatement(sql2)) {
                s.setTimestamp(1, Timestamp.from(i));
                s.setTimestamp(2, Timestamp.from(f));
                try (ResultSet r = s.executeQuery()) {
                    return r.next() ? r.getLong(1) : 0;
                }
            }
        }
    }

    /**
     * Executa auditoria r√°pida apenas verificando se existem dados recentes.
     * 
     * @return true se existem dados das √∫ltimas 24 horas, false caso contr√°rio
     */
    public boolean executarAuditoriaRapida() {
        logger.info("‚ö° Executando auditoria r√°pida");

        try (final Connection conexao = GerenciadorConexao.obterConexao()) {
            final Instant agora = Instant.now();
            final Instant inicio24h = agora.minusSeconds(24 * 60 * 60); // 24 horas em segundos

            return validator.verificarExistenciaDadosRecentes(conexao, inicio24h, agora);

        } catch (final SQLException e) {
            logger.error("‚ùå Erro durante auditoria r√°pida: {}", e.getMessage(), e);
            return false;
        }
    }

    /**
     * Valida uma entidade espec√≠fica.
     * 
     * @param nomeEntidade Nome da entidade a ser validada
     * @return ResultadoValidacaoEntidade com o resultado da valida√ß√£o
     */
    public ResultadoValidacaoEntidade validarEntidadeEspecifica(final String nomeEntidade) {
        logger.info("üîç Validando entidade espec√≠fica: {}", nomeEntidade);

        try (final Connection conexao = GerenciadorConexao.obterConexao()) {
            final Instant agora = Instant.now();
            final Instant inicio24h = agora.minusSeconds(24 * 60 * 60);

            return validator.validarEntidade(conexao, nomeEntidade, inicio24h, agora);

        } catch (final SQLException e) {
            logger.error("‚ùå Erro ao validar entidade {}: {}", nomeEntidade, e.getMessage(), e);
            final ResultadoValidacaoEntidade resultado = new ResultadoValidacaoEntidade();
            resultado.setNomeEntidade(nomeEntidade);
            resultado.setErro("Erro de conex√£o: " + e.getMessage());
            resultado.setStatus(StatusValidacao.ERRO);
            return resultado;
        }
    }
}