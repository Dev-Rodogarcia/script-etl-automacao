package br.com.extrator.auditoria;

import java.sql.Connection;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import br.com.extrator.util.GerenciadorConexao;

/**
 * Servi√ßo principal de auditoria que coordena a valida√ß√£o da completude
 * dos dados extra√≠dos das APIs do ESL Cloud.
 * 
 * Verifica se todas as entidades foram extra√≠das corretamente e gera
 * relat√≥rios de auditoria para identificar poss√≠veis inconsist√™ncias.
 */
public class AuditoriaService {
    private static final Logger logger = LoggerFactory.getLogger(AuditoriaService.class);
    
    private final AuditoriaValidator validator;
    private final AuditoriaRelatorio relatorio;
    
    public AuditoriaService() {
        this.validator = new AuditoriaValidator();
        this.relatorio = new AuditoriaRelatorio();
    }
    
    /**
     * Executa auditoria completa dos dados extra√≠dos nas √∫ltimas 24 horas.
     * 
     * @return ResultadoAuditoria com o resultado da auditoria
     */
    public ResultadoAuditoria executarAuditoriaCompleta() {
        logger.info("üîç Iniciando auditoria completa dos dados extra√≠dos");
        
        final LocalDateTime agora = LocalDateTime.now();
        final LocalDateTime inicio24h = agora.minusHours(24);
        
        return executarAuditoriaPorPeriodo(inicio24h, agora);
    }
    
    /**
     * Executa auditoria dos dados extra√≠dos em um per√≠odo espec√≠fico.
     * 
     * @param dataInicio Data de in√≠cio do per√≠odo
     * @param dataFim Data de fim do per√≠odo
     * @return ResultadoAuditoria com o resultado da auditoria
     */
    public ResultadoAuditoria executarAuditoriaPorPeriodo(final LocalDateTime dataInicio, final LocalDateTime dataFim) {
        logger.info("üîç Executando auditoria para per√≠odo: {} at√© {}", 
                   dataInicio.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),
                   dataFim.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        
        final ResultadoAuditoria resultado = new ResultadoAuditoria();
        resultado.setDataInicio(dataInicio);
        resultado.setDataFim(dataFim);
        resultado.setDataExecucao(LocalDateTime.now());
        
        try (final Connection conexao = GerenciadorConexao.obterConexao()) {
            // Validar cada entidade
            final List<String> entidades = List.of(
                "cotacoes", "coletas", "faturas_a_pagar", "faturas_a_receber", 
                "fretes", "manifestos", "ocorrencias", "localizacao_cargas"
            );
            
            for (final String entidade : entidades) {
                logger.debug("Validando entidade: {}", entidade);
                final ResultadoValidacaoEntidade validacao = validator.validarEntidade(conexao, entidade, dataInicio, dataFim);
                resultado.adicionarValidacao(entidade, validacao);
            }
            
            // Gerar relat√≥rio
            relatorio.gerarRelatorio(resultado);
            
            // Determinar status geral
            resultado.determinarStatusGeral();
            
            logger.info("‚úÖ Auditoria conclu√≠da. Status: {}", resultado.getStatusGeral());
            
        } catch (final SQLException e) {
            logger.error("‚ùå Erro durante auditoria: {}", e.getMessage(), e);
            resultado.setErro("Erro de conex√£o com banco de dados: " + e.getMessage());
            resultado.setStatusGeral(StatusAuditoria.ERRO);
        } catch (final Exception e) {
            logger.error("‚ùå Erro inesperado durante auditoria: {}", e.getMessage(), e);
            resultado.setErro("Erro inesperado: " + e.getMessage());
            resultado.setStatusGeral(StatusAuditoria.ERRO);
        }
        
        return resultado;
    }
    
    /**
     * Executa auditoria r√°pida apenas verificando se existem dados recentes.
     * 
     * @return true se existem dados das √∫ltimas 24 horas, false caso contr√°rio
     */
    public boolean executarAuditoriaRapida() {
        logger.info("‚ö° Executando auditoria r√°pida");
        
        try (final Connection conexao = GerenciadorConexao.obterConexao()) {
            final LocalDateTime agora = LocalDateTime.now();
            final LocalDateTime inicio24h = agora.minusHours(24);
            
            return validator.verificarExistenciaDadosRecentes(conexao, inicio24h, agora);
            
        } catch (final SQLException e) {
            logger.error("‚ùå Erro durante auditoria r√°pida: {}", e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Valida uma entidade espec√≠fica.
     * 
     * @param nomeEntidade Nome da entidade a ser validada
     * @return ResultadoValidacaoEntidade com o resultado da valida√ß√£o
     */
    public ResultadoValidacaoEntidade validarEntidadeEspecifica(final String nomeEntidade) {
        logger.info("üîç Validando entidade espec√≠fica: {}", nomeEntidade);
        
        try (final Connection conexao = GerenciadorConexao.obterConexao()) {
            final LocalDateTime agora = LocalDateTime.now();
            final LocalDateTime inicio24h = agora.minusHours(24);
            
            return validator.validarEntidade(conexao, nomeEntidade, inicio24h, agora);
            
        } catch (final SQLException e) {
            logger.error("‚ùå Erro ao validar entidade {}: {}", nomeEntidade, e.getMessage(), e);
            final ResultadoValidacaoEntidade resultado = new ResultadoValidacaoEntidade();
            resultado.setNomeEntidade(nomeEntidade);
            resultado.setErro("Erro de conex√£o: " + e.getMessage());
            resultado.setStatus(StatusValidacao.ERRO);
            return resultado;
        }
    }
}